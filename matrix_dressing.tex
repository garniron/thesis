
\documentclass[./thesis.tex]{subfiles}

 
\begin{document}


\section{Matrix dressing}

So far we have used the second order perturbation to build a zeroth-order wavefunction $\ket \Psi$ using CISPI, and estimate its distance to the FCI energy with a stochastic estimation of $\EPT$.

In both cases we have computed the interaction between $\ket \Psi$ and the external space, but we have not let $\ket \Psi$ be revised under those interactions. This idea is based on the so-called \Bk approximation proposed by Gershgorn and Shavitt.\cite{Gershgorn_1968}

This can be achieved using the intermediate Hamiltonian theory,\cite{0305-4470-18-5-014} intermediate Hamiltonians being a class of effective Hamiltonians\cite{lindgren1982atomic} where not all roots are exact eigenvalues of the full Hamiltonian.
The principle is to build a so-called intermediate Hamiltonian ${\bf \tilde H}$ which, when diagonalized, yields a wavefunction that takes into account the effect of an external space on the internal space. 


Sticking to the state-specific case, the general principle can be understood as follow. This formulation, as it is limited to the state-specific case, is somewhat different and wishes to be more intuitive than the one presented in the article.
Fully taking into account the external space requires to solve 

\newcommand{\Hzero}{{H}^{(0)}}
\newcommand{\hcplbold}{{\bf h}}
\newcommand{\Hzerobold}{{\bf H}^{(0)}}
\newcommand{\hcpl}{{h}}

\begin{equation}
\begin{pmatrix}
\Hzerobold &  \hcplbold\\ 
\hcplbold^\dagger & {\bf H}^{(1)}
\end{pmatrix} \begin{pmatrix}
{\bf c}\\ 
{\bf c}^\alpha
\end{pmatrix}=E\begin{pmatrix}
{\bf c}\\ 
{\bf c}^\alpha
\end{pmatrix}.
\end{equation}

With ${\bf H}^{(0)}$ and ${\bf H}^{(1)}$ the zeroth and first-order Hamiltonians, $\bf h$ the coupling term between zeroth and first order spaces, ${\bf c}$ the coefficients for the zeroth-order space and ${\bf c}^\alpha$ the coefficients for the external space.

This diagonalization is normally not feasible due to the external space being too large. However, if we are willing to neglect the external-to-external and internal-to-external influences - in other words, if we freeze the external space - we can only solve the eigenequations associated with internal determinants. As usual, associating $I$ and $J$ to internal determinants and $\alpha$ to external ones, for line $I$ we have
\begin{equation}
\qty(\Hzero_{II} - E)c_I  + \sum_{J \neq I} {c_J \Hzero_{IJ}} + \sum_\alpha {c_\alpha \hcpl_{I \alpha}} = 0.
\label{eq:eignen_sum}
\end{equation}

Obviously, since we froze the external space, we need some way to estimate ${\bf c}^\alpha$. In the presented paper, we used a perturbative estimation consistently with what we used in CIPSI and $\EPT$ computations. Because of this, whenever $\bf c$ is revised, ${\bf c}^\alpha$ needs to be recomputed as well. This makes \Bk an iterative method.

Because $c_\alpha$ coefficients are frozen, $\sum_\alpha {c_\alpha H_{I \alpha}}$ is merely a constant added to the eigenequation of line $I$. Renaming this term $\delta_I$, we can rewrite \ref{eq:eignen_sum}
\begin{equation}
\qty(\Hzero_{II} - E + \frac{\delta_I}{c_I})c_I  + \sum_{J \neq I} {c_J \Hzero_{IJ}} = 0.
\label{eq:eignen_delta}
\end{equation}

It appears solving this new system of linear equations is equivalent to diagonalizing 
\begin{equation}
{\bf \tilde H} = \Hzerobold + \Deltabold 
\end{equation}
with $\Deltabold$ a diagonal matrix
\begin{equation}
\begin{cases}
\Delta_{II}=\frac{\delta_I}{c_I}\\
\Delta_{IJ}=0 & \text{if } I \neq J.
\end{cases}
\end{equation}

Here ${\bf \tilde H}$ is the intermediate Hamiltonian and ${\bf \Delta}$ the so-called \emph{dressing matrix}. Consequently ${\bf \tilde H}$ may be referred to as a \emph{dressed Hamiltonian}. 
Note that the dressing matrix is diagonal because of an arbitrary rewriting of Eq.~\eqref{eq:eignen_sum} into Eq.~\eqref{eq:eignen_delta}. We can actually build ${\bf \Delta}$ in any way that fulfills
\begin{equation}
\sum_J c_J \Delta_{IJ}  = \delta_I.
\label{eq:arbitrary_dressing}
\end{equation}

While the choice of which elements of $\Deltabold$ are non-zero is arbitrary, it can be of importance for numerical reasons (in addition to obvious storage reasons). However, because we diagonalize ${\bf \tilde H}$ using a Davidson diagonalization, this is of no concern to us. Indeed, Davidson's diagonalization only requires the knowledge of ${\bf \tilde H} {\bf c}$ and of the diagonal of ${\bf \tilde H}$ 
\begin{equation}
{\bf \tilde H} {\bf c} = \Hzerobold\, {\bf c} + {\bf \Delta}\, {\bf c}.
\end{equation}
Because of \ref{eq:arbitrary_dressing}, we have by construction
\begin{equation}
\Deltabold\, {\bf c} = {\pmb \delta}
\end{equation}
with ${\pmb \delta}$ the vector $\qty(\delta_1, \ldots, \delta_{\Ndet})$.
Algorithmically, it boils down to computing ${\pmb \delta}$, which is more expensive to compute than the product ${\bf \tilde H}\,{\bf U}$ needed for Davidson's diagonalization. But unlike ${\bf \tilde H}\,{\bf U}$ which is too large to be stored, and needs to be re-computed on the fly at each Davidson iteration, ${\pmb \delta}$ is fixed and can easily be stored.


An improved version to this original idea was proposed by Davidson and co-workers under the name shifted-\Bk,\cite{Nitzsche_1978a, Nitzsche_1978b, Rawlings_1983, Kozlowski_1995, Kozlowski_1994a, Kozlowski_1994b, Kozlowski_1994c} which is the one we implemented. Details about this improvement and on how it can be generalized to a multi-state case are available in the presented article.



\section{Implementation}
%For clarity, indices will be named depending on what they refer to
%\begin{itemize}
%\item
%$i,j$ refer to samples/generator determinants
%\item
%$m$ refers to checkpoints
%\item
%$t$ refers to teeth
%\end{itemize}

In some respect, computing the dressing matrix is akin to computing $\EPT$. The dressing matrix can be decomposed as a sum of elementary dressing matrices $\deltabold_\alpha$, each one associated with a particular $\ket \alpha$, just like $\EPT$ is a sum of $e_\alpha$. It is possible to pack those elementary matrices together like we packed $\ket \alpha$ together for $\EPT$.
\begin{equation}
\deltabold_I = \sum_{\alpha \in \mathcal{A}_I} \deltabold_\alpha
\end{equation}
\begin{equation}
\deltabold = \sum_{I} \deltabold_I
\end{equation}
So as we only need $\tilde{\bf H}{\bf c}$ for Davidson's algorithm, the quantity we sample is 
\begin{equation}
\deltabold_I = \Deltabold_I\, {\bf c} = \sum_{\alpha \in \mathcal{A}_I} \deltabold_\alpha\, {\bf c}
\end{equation}

Thus, ${\pmb \delta}_I$ is a sum over external determinants, and requires to find connections between those determinants and the wavefunction. Presumably, the elementary dressing vectors $\deltabold_I$ will have a norm decreasing like $e_I$. Indeed, 
\begin{equation}
e_I = \frac{{\bf c}^\dagger\, \Deltabold_I\, {\bf c}}{{\bf c}^\dagger {\bf c}} = {\bf c} \cdot \deltabold_I
\label{eq:c_delta_i}
\end{equation}
Using the Cauchyâ€“Schwarz inequality
\begin{equation}
e_I \le \sqrt{ \qty (\deltabold_I \cdot \deltabold_I) \qty({\bf c}\cdot{\bf c}) } \le
\norm{\deltabold_I}.
\end{equation}

With that in mind, is seems possible, theoretically, to generalize our hybrid stochastic-deterministic PT2 for computing dressing vectors.
However there are a few significant differences.
\begin{itemize}
\item
We were estimating a scalar, now we are estimating a vector. How can we quickly estimate the running error?
To address this problem, we decided to compute the error bar associated with $E_{\Delta}$, the energy contribution of $\Deltabold$. Our dressed matrix being $\mathbf{H} + \Deltabold$, the energy is
\begin{equation}
\frac{\mel{\Psi}{\widehat{H} + \widehat{\Delta}}{\Psi}}{\braket{\Psi}{\Psi}} =
\frac{ \Hij{\Psi}{\Psi}}{\braket{\Psi}{\Psi}} + \frac{\mel{\Psi}{\widehat{\Delta}}{\Psi}}{\braket{\Psi}{\Psi}} = \Evar + E_{\Delta} 
\end{equation}
where $E_{\Delta}$ is estimated the same way as $E_{PT2}$ was, based on individual contributions $e_I$ (see eq.~\eqref{eq:c_delta_i}).
\item
In both cases we have $\Ngen$ samples, however in the case of $\EPT$ each sample is a scalar, here each sample is a vector of size $\Ndet$. It is easy to store $\Ngen$ scalars, not to store $\Ngen$ vectors of size $\Ndet$. In addition, these vectors must be transmitted from slave nodes to a master node, creating a potential network bottleneck, scaling with $\Ndet$.
\item
In the case of PT2 (at least in its Epstein-Nesbet version), each connection found only requires an increment of some elements of $P(G_{pq})$. At no point 2 connections need to be known at the same time. This is different for methods implemented with matrix dressing. It is possible that one needs to know the detail of which internal determinants an $\ket \alpha$ connects to, in order to be able to compute $\deltabold_\alpha$.
\end{itemize}



Implementationally speaking, just like the state-specific version requires computing a single $\deltabold$ vector, the multi-state version requires a $\deltabold^{(k)}$ vector to be computed for each desired state $k$. This, in principle, should come with minimal cost, since the loop over states can be set as the innermost one. 

In practice, since the exact computation of $\deltabold^{(k)}$ is as expensive than that of $\EPT$, we need to use the same hybrid stochastic-deterministic approach. Unfortunately, using state-average coefficients for the sampling did not yield satisfying results, so we have to stick to state-specific sampling and thus compute each $\deltabold^{(k)}$ individually. Therefore we will ignore the state from now on.

The multi-state Davidson diagonalization, however, is done a single time per shifted-\Bk iteration.


\subsection{Storage}

The core idea is that, in a Monte-Carlo scheme, even an "exotic" one like our hybrid approach, the estimated result has to be a linear combination of all samples. At any point $m$ of the Monte-Carlo computation corresponding to $M_m$ combs having been drawn, we can write our estimated dressing vector $\deltabold^m$ as :


\begin{equation}
\deltabold^m = \sum_{I} \mu^m_{I} \deltabold_I
\end{equation}


The values for $\mu^m_I$ have no dependence on those of $\delta_I$. They only depend on what samples have been drawn so far. Since we decide beforehand which combs are going to be drawn, we can compute $\mu$ vector for any point of the Monte-Carlo before any sample has been computed. The values we chose for $M_m$ act as predetermined "checkpoints".

%This allows us to set up "checkpoints" for predetermined values of $n$. These value are referred to as $M_m$ with $M_0 = 0$ and $M_m < M_{m+1}$.
\begin{comment}
\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=1.00\columnwidth]{figures/matrix_dressing/checkpoint}
		\caption{\label{checkpoint}}
		A REFAIRE EN VERTICAL AVEC J[j]
	\end{center}
\end{figure}
\end{comment}


They can be set at any arbitrary point, but they must be determined beforehand and cannot be changed during the computation ; we will only be able to get results at those points.
For checkpoint $m$, we start with a null vector for $\delta^m$. Each time an elementary vector $\delta_I$ is computed
we increment it 



\begin{equation}
\delta^m \gets \delta^m + \mu_I^{m} \delta_I
\end{equation}


Once this has been done, $\delta_I$ can be discarded. Indeed, when checkpoint $m$ is reached, $\delta^{m}$ has its final value, as obviously $\mu_I^{m} = 0$ for any $\delta_I$ sample that hasn't yet been drawn at checkpoint ${m}$.
For convenience, some parameters can be defined as functions of a checkpoint reached

\begin{equation}
\dot t_m
\end{equation}
the first non-deterministic tooth when checkpoint $m$ is reached, and

\begin{equation}
\dot n_0(m) = n_0(\dot t_m)
\end{equation}

the size of the deterministic range when $m$ is reached.


$\mu$ is defined as follow

\begin{equation}
\mu^m_i = 
\begin{cases}
1 & \text{if } i \leq \dot n_0(m) \\
\frac{W_T \times M_{m,i}}{w_i \times M_m} & \text{if } i > \dot n_0(m)
\end{cases}
\end{equation}


with $M_{m,i}$ the number of times sample $i$ has been drawn at checkpoint $m$.


The memory cost for a checkpoint $m$ is $2 \times \Ndet$ floats, corresponding to the storage of $\mu^m$ and $\delta^m$. This cost is small enough to allow setting up quite a few checkpoints. However, in addition to this memory cost, comes some computational cost. If we set up $N_{cp}$ checkpoints, it implies each time a sample is drawn, we will have, theoretically, to increment $N_{cp}$ vectors of size $\Ndet$. For quicker jobs, this price may not be negligible. It gets worse if, as was the case in our first implementations, a collector is in charge of updating checkpoints for multiple slaves. 


We can drastically reduce the amount of writing required for each sample by rewriting $\delta^m$.
Firstly, we define $\delta^{D,t}$ as the total dressing contribution for teeth $\mathcal{T}_t$
\begin{equation}
\delta^{D,t} = \sum_{I \in \mathcal{T}_t} \delta_I
\end{equation}

We rewrite $\delta^m$ as

\begin{equation}
\label{eq:rewrite1}
\delta^{m} = \sum_{t=0}^{\dot t_m - 1} \delta^{D,t}+ \frac{1}{M_m} \sum_{I} \gamma^m_{I} \delta_I
\end{equation}

The second term being $\delta^m$ without its deterministic contribution, we can trivially write (defining $\gamma^ 0_I=0$ for convenience)

\begin{equation}
\gamma^m_i = 
\begin{cases}
0 & \text{if } i \leq \dot n_0(m) \vee m=0 \\
\mu^m_i \times M_m = \frac{W_T \times M_{m,i}}{w_i} & \text{if } i > \dot n_0(m) \wedge m \neq 0
\end{cases}
\end{equation}

We define

\begin{align}
\delta^{S,m} = \sum_I (\gamma^m_I - \gamma^{m-1}_I) \delta_I
\end{align}


We can rewrite the second term of Eq.~\eqref{eq:rewrite1}
\begin{equation}
\frac{1}{M_m}\sum_{I} \gamma^m_{I} \delta_I = \frac{1}{M_m} \sum_{p=1}^m \delta^{S,p}
\end{equation}

And write the final form or $\delta^m$ as
\begin{equation}
\delta^m=\sum_{t=0}^{\dot t_{m}-1} \delta^{D,t} + \frac{1}{M_m} \sum_{p=1}^m \delta^{S,p}
\end{equation}

The vectors we need to store are $\delta^{D,t}$ and $\delta^{S,m}$. Each time we compute an elementary dressing vector $\delta_I$, the need for update goes as follow

\begin{itemize}
\item
$\delta^{D,t}$ with $I \in \mathcal{T}_t$. This is exactly one write.
\item
$\delta^{S,m}$ where $\gamma^m_I - \gamma^{m-1}_I \neq 0$. This is
 \begin{itemize}
 \item
 	No write if $I$ is moved to $\mathcal{D}$ in the same checkpoint it is first drawn or computed for tooth filling
 \item
 	Otherwise, one write per checkpoint in which it is drawn until the one where it is moved to $\mathcal{D}$, inclusive.
 \end{itemize}
 While this increases the theoretical maximum of writes to $N_{cp}+1$ per sample, it is much lower in practice.
\end{itemize}

For convenience we define

\begin{equation}
\tilde \mu^m_I = \gamma^m_I - \gamma^{m-1}_I
\end{equation}


The task queue is built in a fashion similar to the one for $\EPT$ computation, with some differences.
\begin{itemize}
\item
$M_{m,I}$ are evaluated for computation of $\tilde \mu^m_I$.
\item
Instead of $R$ we evaluate $R^{-1}$, based on indices of checkpoints rather than of combs. In the algorithm for $\EPT$, when the first $j$ tasks are completed, comb of index $R[j]$ is available. Here, when the first $R^{-1}[m]$ tasks have been completed, checkpoint $m$ has just become computable.
\item
We create sample subsets $\mathcal{P}_m$ associated with checkpoints. $I \in \mathcal{P}_m$ iff
\begin{equation}
R^{-1}[m-1] < j \leq R^{-1}[m]  \;; R^{-1}[0] = 0
\end{equation}
with $j$ the task index associated with $I$, i.e. $J[j]=I$. These sets are tracked using an array $P$ so that $P[I]=m$ iff $I \in \mathcal{P}_m$.

\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=0.45\columnwidth]{figures/matrix_dressing/taskqueue}
		\caption{Task queue divided in checkpoints $\mathcal{P}_m$. The task array $J$ contains the indices of samples to be computed. When all tasks in sets $\mathcal{P}_{p\leq m}$ have been computed, checkpoint $m$ is computatble.}
		\label{fig:task_queue}
	\end{center}
\end{figure}

\begin{algorithm}
	\caption{Compute task queue and checkpoints.}
	\label{PRECOMPUTE_MONTECARLO}
	\tcc{Computes task queue}
		\KwData{$M_m$ the desired number of combs for checkpoints $m$. $M_0 = 0$ for convenience. $M_{n+1} > M_n$, $\exists M_n > \Ngen$}
		\KwResult{$J$ the task array, $N_{cp}$ the number of checkpoints, $P$ the array so that $P[I] = m$ iff $I \in \mathcal{P}_m$, $R^{-1}$ the array so that checkpoint $m$ becomes available when the first $R^{-1}[m]$ jobs have been computed.}
		$\tilde M$ array size $\Ndet$ initialized with $0$\;
		$u$ array size $\Ngen$ initialized with random numbers $\in [0,1)_\mathbb{R}$ \;
		$d$ a boolean array size $\Ngen$ initialized with $FALSE$.
		
		$R^{-1}[0] \gets 0$ \;
		$N_c \gets 0$ \;
		$N_j \gets n_0(1)$ \;
		\For{$i=1,N_j$}{
			$d[i] \gets TRUE$ \;
			$J[i] \gets i$ \;
		}
		
		$N_{cp} \gets 0$ \;
		$F \gets N_j+1$ \;
		\While{$N_j < \Ngen$}{
			ADD\_COMB shown as algorithm \ref{alg:FILL_TOOTH} \;
			FILL\_TOOTH shown as algorithm \ref{alg:ADD_COMB} \;
			\If{$M_{N_{cp}+1} = N_c$}{
				$N_{cp} \gets N_{cp}+1$ \;
				$R^{-1}[N_{cp}] \gets N_j$ \;
				 %$cpthreshold[m] \gets N_j$ \;
				$M_{N_{cp},*} \gets \tilde M$ \;
			} 
		}
		\If{$R^{-1}[N_{cp}] \neq N_j$}{
			\tcc{adds a final checkpoint}
			$N_{cp} \gets N_{cp}+1$ \;
			$R^{-1}[N_{cp}] = N_j$ \;
		}
		optimize task queue with algorithm \ref{alg:OPTIMIZE_MONTECARLO} \;
		\For{$m=1,N_{cp}$}{
		\For{$i=R^{-1}[m-1]+1,R^{-1}[m]$}{
			$P[J[i]] \gets m$ \;
		}
		}
\end{algorithm}

%An extra array $P[i]=m$ is built, mapping a sample index $i$ to the checkpoint $m$ in which it is first needed ; in other words, when sample $i$ needs to be evalutated, checkpoints up to $m-1$ have been fully built.


\begin{algorithm}
	\KwResult{Modifies $J$ the task array and $R^{-1}$ the array defining the boundaries of checkpoints in $J$.}
	\caption{Optimize checkpoints so that they are available faster.}
	\label{alg:OPTIMIZE_MONTECARLO}
	
	%\SetKwFunction{FMain}{OPTIMIZE\_MONTECARLO}
	%\SetKwProg{Fn}{Function}{:}{}
	
	%\Fn(\tcc*[h]{Optional algorithm to reorder jobs so checkpoints are reached as fast as possible.}){\FMain{some args}}{
		%$lastNj \gets 1$ \;
		\For{$m=1,N_{cp}$}{
			$Nmoved \gets 0$ \;
			$firstTask \gets R^{-1}[m-1]+1$ \;
			\For{$j=firstTask,R^{-1}[m]$}{
				\If{$M_{m,J[j]} = 0 \wedge J[j] > \dot n_0(m)$}{
					\tcc{ensures moved jobs are at the end of the checkpoint once sorted}
					$J[j] \gets J[j] + \Ngen$ \;
					$Nmoved \gets Nmoved + 1$ \;
				}
			}
			sort array J from $firstTask$ to $R^{-1}[m]$, inclusive \;
			\tcc{moved jobs are sent to the next checkpoint}
			$R^{-1}[m] \gets R^{-1}[m] - Nmoved$ \;
			\tcc{restores moved jobs original value}
			\For{$j=R^{-1}[m]+1,R^{-1}[m] + Nmoved$}{
				$J[j] \gets J[j] - \Ngen$ \;	
			}
		}
		%$k \gets 1$ \;		
		%\For{$i=2,N_{cp}$}{
	%		\If{$R^{-1}[k] \neq R^{-1}[i]$}{
	%			$k \gets k + 1$ \;	
%				$R^{-1}[k] \gets R^{-1}[i]$ \;
%			}		%
%		}
%		$N_{cp} \gets k$ \;
\end{algorithm}

Algorithm \ref{alg:OPTIMIZE_MONTECARLO} is an optional reorganization of jobs order. It ensures results for a checkpoint are available as quickly as possible, without altering them.
%Some checkpoints may however be removed if no extra computation is required to reach the next one ; this situation can't happen in the unoptimized task queue, because of the tooth filling. Two things are taken into consideration:
\begin{itemize}
\item
Because no result is available between two checkpoints, the order in which jobs are processed between two checkpoints is irrelevant for the result. So, as is usually the case with parallel jobs, we would like to do the longest tasks first, so that we don't get an extra delay due to a massive task being done last. Therefore, jobs should always be in ascending order ( descending computational time) between two checkpoints.
\item
Because of the "tooth filling", sometimes samples computed inside a checkpoint are not involved in its result. Since tooth filling picks the first non-computed jobs, they tend to be of high computational cost. The algorithm iterates over checkpoints in ascending order, each time moving such sample to the next checkpoint. Thus, every sample is moved to the first checkpoint it is actually involved in, either deterministically or stochastically.
\end{itemize}



\begin{algorithm}
	\caption{Compute $\tilde \mu$, $\dot t$ and $\dot n_0$}
	\label{COMPUTE_MU}
		\KwData{$J$, $R^{-1}$, $n_0$, $N_{teeth}$}
		\KwResult{ $\tilde \mu$, $\dot t$ and $\dot n_0$}
		$\tilde \mu^*_* \gets 0$ \;
		$F \gets n_0(1)+1$ \;		
		\For{$m=1,N_{cp}$}{
			\For{$i=R^{-1}[m-1]+1,R^{-1}[m]$}{
				$d[J[i]] \gets true$ \;			
			}
			\While{$d(U+1)$}{
				$U \gets U+1$ \;
		  	}
		  	
		  	$\dot t_m \gets N_{teeth}+1$ \;
			$\dot n_0(m) \gets \Ngen$ \;
			
			\For{$t=2,N_{teeth}+1$}{
				\If{$U < n_0(t)$}{% rTeethI[t]$}{
					$\dot t_m \gets t-1$ \;
					$\dot n_0(m) \gets n_0(t-1)$ \;
					break loop \;
				}
			}
				
			\For{$i=\dot n_0(m)+1, \Ngen$}{
				$\tilde \gamma^m_i \gets \frac{W_T \times M_{m,i}}{w[i]}$ \;
			}
		}
		
		\For{$m=N_{cp},2,-1$}{
			$\tilde \mu^m_* \gets \tilde \gamma^m_* - \tilde \gamma^{m-1}_*$ \;
		}
\end{algorithm}



\newcommand{\cpsent}{\text{cp\_sent}}
\newcommand{\cpdone}{\text{cp\_done}}
\newcommand{\cpmax}{\text{cp\_done}}
\newcommand{\willsend}{\text{will\_send}}

\begin{algorithm}
\caption{\alert{CAPTION TO DO}}
	\tcc{code for a slave node, OMP parallel}
	
	cp\_done, cp\_sent : shared scalars initialized to $0$ \;
	cp\_max : shared array size $N_{proc}$ initialized to $0$ \;
	$f$ : shared array size $\Ngen$ initialized to $0$ \;
	
	\tcc{loop for each core $iproc$}
	\While{$\cpdone > \cpsent \vee m < N_{cp}+1$ }{
		try to get task $(I,s)$ from queue \;
		\uIf{task was available}{
			$m$ so that $I \in \mathcal{P}_m$ \;	
		}\Else{
			$m \gets N_{cp} + 1$ \;		
		}
		will\_send $\gets 0$ \;
		-- OMP CRITICAL -- \;
		$\cpmax[iproc] \gets m$ \;
		$\cpdone \gets min(\text{cp\_max}) -1$ \;
		\If{$\cpdone > \cpsent$}{
			$\cpsent \gets \cpsent + 1$ \;		
			$\willsend \gets \cpsent$ \;				
		}
		-- END OMP CRITICAL -- \;
		\If{$\willsend \neq 0$}{
			send $\delta^{\willsend}$ (shown in algorithm \ref{alg:build_checkpoints})
		}
		\If{$m < N_{cp}+1$}{
			perform task $(I,s)$ (shown in algo \ref{alg:update_checkpoints}) \;
		}
	}
\end{algorithm}


\begin{algorithm}
	\caption{Perform task $(I,s)$, that is, update \alert{`node-local''} partial values of $ \delta^{D,t}$ and $ \delta^{S,m}$.}
	\label{alg:update_checkpoints}
	\KwData{global shared scope (at node level): $\delta^{D,t}$ and $\delta^{S,m}$ initialized with $0$, $f$ an array size $\Ngen$ initialized with $0$. The fragmentation count}
	
	\KwData{from outer scope : $s, I$} 
	\BlankLine
	$m $ so that $I \in \mathcal{P}_m$ \;
	$t$ so that $I \in \mathcal{T}_t$ \;
	
	compute $\delta_{I,s}$ (\alert{fragment $s$ of $\delta_{I}$})\;
	\tcc{lock global arrays before update}
	$\delta^{D,t} \gets \delta^{D,t} + \delta_{I,s}$ \;
	\For{$p=m,N_{cp}$}{
		\If{$\tilde \mu^p_I \neq 0$}{
			$\delta^{S,p} \gets \delta^{S,p} + \tilde \mu^{p}_I \delta_{I,s}$ \;
		}
	}
	$x \gets {\bf c} \cdot \delta_{I,s}$ \;
	-- OMP ATOMIC -- \;
	$e_I \gets e_I + x$ \;
	$f[I] \gets f[I] + 1$ \;
	-- OMP END ATOMIC -- \;
\end{algorithm}


\begin{algorithm}
	\caption{Build $ \delta^m$ and send it to master node.}
	\label{alg:build_checkpoints}
	\tcc{compute partial value of $\delta^m$ with partial values of $\delta^{D,t}$ and $\delta^{S,m}$}
	\tcc{sending information for checkpoint $m$}
	
	$\dot f \gets \sum_{I \in \mathcal{P}_{p\leq m}} f[I]$ \;
	\If{$\dot f = 0$}{
		return \;
	}
	
	$\delta^m \gets 0$ \;
	\tcc{reverse loop for numerical precision}
	\For{$p=m,1,-1$}{
		$\delta^m \gets \delta^m + \delta^{S,p}$
	}
	$\delta^m \gets \frac{\delta^m}{M_m}$ \; 
	\For{$t=\dot t_m-1,0,-1$}{
		$\delta^m \gets \delta^m + \delta^{D,t}$ \;
	}
	%$\mathcal{I}$ the set of $I \in \mathcal{P}_m$ with $f[I] > 0$ \;
	send ($m$, $\delta^m$, $e_{I \in \mathcal{P}_m}$, $\dot f$) \;
\end{algorithm}


\begin{algorithm}
	$m \gets 1$ \;
	$c \gets 1$ \;
	$S$ and $S^{(2)}$ float arrays size $N_{teeth}+1$ initialized with $0$ \;
	$e_* \gets 0$ \;
	$\dot f$ integer array size $N_{cp}$ initialized with $\dot f[m] = \sum_{I \in \mathcal{P}_{p\leq m}} F_{I}$ \;
	\While{}{
		\uIf{$\dot f[m] = 0$}{
			\tcc{see algorithm \ref{alg:UPDATE_S}}
			\While{$c \leq M_m$}{
				$S_* \gets S_* + B_*(u[c])$ \;
				$S^{(2)}_* \gets S^{(2)}_* + B_*(u[c])^2$ \;
				$c \gets c+1$ \;
				
			}
			\tcc{$E$ for printing purpose}
			$E \gets \sum_{I \leq \dot{n}_0(m)} e_I + {S_t}/c$ \;
			$t \gets \dot{t}_m$ \;
			error $\gets \sqrt{(S_t^{(2)} - {S_t}^2) (c-1)^{-1} }$ \;
			exit loop if $m=N_{cp}$ \;
			\tcc{chose to not exit if next checkpoint is available}
			exit loop if acceptable error and $f[m+1] \neq 0$\;
			
			$m \gets m+1$ \;
		}
		\Else{
			
			retrieve $(\breve l,  \breve {\delta}^l$, $ \breve {e}_{I \in \mathcal{P}_l}, \breve f)$  \;
			increment $e_{I \in \mathcal{P}_l}$ with $\breve e_{I \in \mathcal{P}_l}$\;
			increment $\delta^l$ with $\breve  \delta^l$ \;
			decrement $\dot f[l]$ with $\breve  f$\;
		}
	}
	$\delta^m$ is the estimated dressing vector \;
	
\end{algorithm}


\section{Conclusion}

In this chapter we have implemented a stochastic version of the shifted-\Bk algorithm, using the same algorithm we used for computation of $\EPT$, and were able to get acceptable accuracies performing a few percent of the full computation.
The additional difficulties of estimating a vector rather than a scalar were solved by setting a limited number of pre-determined checkpoints between which no result is available.

The fact that we implemented the shifted-\Bk method boils down to our choice to build the external space using Epstein-Nesbet perturbative estimation for $c_\alpha$. However, the proposed algorithm do not put any particular restriction on $c_\alpha$. From this stemmed the idea of a more general framework to allow easy experimentation of the effect of different external spaces, which was used to design an MR-CCSD method as shown in chapter \ref{chap:exp_dressing}.


\section{Selected configuration interaction dressed by perturbation}
\includepdf[page=2-]{article_sbk}

\includepdf[page=-]{article_sbk_sup}


\end{document}
