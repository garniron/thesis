 
\section{Generating a subspace of determinants}
\alert{
duplicates are avoided by checking connection to the past \\
******** (ptet exemple avec generator\_CAS versus generator\_full PSI is filtered with different function and supplied to the module using cas\_sd ( cas\_sd, mrcc ) or full\_ci ( pt2 stoch ) )?? \\
================
}

Generally speaking, a subspace of determinants is defined by a reference and a class of excitation applied to it.
\alert{
Because of the determinant-driven approach, it may not be possible to store all the determinants of the considered subspace. \textbf{Pourquoi c'est lie au determinant-driven?}
}



\paragraph{Reference space}
The \QP allows to define either a determinants of a CAS (Complete Active Space) or the full-CI space as the reference.\footnote{Although the full-CI space is a particular CAS, it is treated differently at the code level.}

\paragraph{Excitation class}
The excitations to be applied to determinants of the reference space are defined by sets of orbitals describing:
\begin{itemize}
\item
Single excitations
\item
The first excitation of a double excitation
\item
The second excitation of a double excitation
\end{itemize}
For each set category, there is one set for the allowed holes and one set for the allowed particles.
This defines the rules used to generate determinants of the external space from the reference determinants.

Typically, to define a CAS-SD (CAS augmented with all single and double excitations applied to all the determinants of the CAS), one defines:
\begin{description}
\item [Core orbitals:]
Orbitals always doubly occupied. They are not part of any of the sets.
\item [Inactive orbitals:]
Orbitals in which one or two holes may be created. They are part of the all the \emph{hole} sets.
\item [Active orbitals:]
Orbitals defining the CAS. They are part of all the sets.
\item [Virtual orbitals:]
Orbitals in which one or two particles may be created. They are part of the all the \emph{particle} sets.
\item [Deleted orbitals:]
Orbitals removed from the calculation, always unoccupied. They are not part of any set.
\end{description}


 As will be seen later, determinants are selected iteratively. The general procedure is shown 



\begin{algorithm}
        \caption{GENERAL\_SELECTION}    
        \label{alg:GENERAL_SELECTION}   
        $\ket{\Psi} \gets \ket{\HF}$\;
        Build the sets $\set{H}_0, \set{H}_1, \set{H}_2, \set{P}_0, \set{P}_1, \set{P}_2$ \;
        $\set{T}$: the set of excitations allowed on the reference based on $\set{H}_0, \set{H}_1, \set{H}_2, \set{P}_0, \set{P}_1, \set{P}_2$ \;
        
        \While{some condition}{
                $\set{D}$: the set of determinants in $\ket{\Psi}$ \;
                $\set{D}' \gets \{ \}$ \;
                \For{$i \gets 1, \Ndet$}{
                        \ForAll{$\hat{T}_j \in \set{T}$}{
                                $\kalpha \gets \ordering \hat{T}_j \ket {D_i}$ \;
                \If{$\kalpha \neq 0$}{
                /* Check if $\kalpha$ was not already generated before */ \;
                \textit{found} $\gets$ False \;
                \For{$l \gets 1, i-1$}{
                        \ForAll{$\hat{T}_k \in \set{T}$}{
                                $\textit{found} \gets \ior{\textit{found}}
            {(\ordering \hat{T}_k \ket{D_{l}} \neq \kalpha)}$ \;
                                }
                                }
                \If{$\iand{(\neg \textit{found})}{\textit{Selection\_criterion}}$ }{
                $\set{D}' \gets \set{D}' \cup \kalpha $ \;                      
                }
                                }
                        }
                }
                do some selection in $\set{D}'$ \;
                add selected determinants to $\set{D}$ \;
                diagonalize $\hat{H}$ in $\set{D}$ to obtain $\ket{\Psi}$ \;
        }
\end{algorithm}




\section{excitation driven(?) - (TOTO, INUTILE DE LIRE) a reecrire/tester}

There is a way to find connections using an 'excitation driven' approach, that would be closer to an integral-driven approach. Essentially, it is possible to find all determinants of an arbitrary set that connects by a particular excitation, with a complexity linear (logarithmic???) with $N_{det}$.
To understand this approach, we will considered bitstrings as single integers of arbitrary size.

SCHEMA


\begin{equation}
\hat T_{a}^{b} D = E
\end{equation}

\begin{equation}
ibclr(ibset(I_D, b), a)
\end{equation}
 
 
\begin{equation}
ibclr(X, a) = X - ISHFT(1,a) ; ibtest(X,a) == TRUE
\end{equation}

\begin{equation}
ibset(X, b) = X + ISHFT(1,b) ; ibtest(X,b) == FALSE
\end{equation}

If $\hat T_{a}^b$ can be applied to $D$, 
\begin{equation}
ibtest(I_D,a)\ and\ not\ ibtest(I_D,b)
\end{equation}

\begin{equation}
I_E = I_D + I_T ; I_T = ISHFT(1,b) - ISHFT(1,a)
\end{equation}

As can be seen, it is possible to have an integer representation of an excitation.

\begin{equation}
TD = E \implies I_E = I_D + I_T ; E \neq 0
\end{equation}

It must be noted that, if $T$ cannot be applied to $D$, $I_E = I_D + I_T$ will, in most cases, not be a valid reprensentation of a determinant ; that is, $popcnt(I_{E_\alpha}) \neq N_{e,\alpha} \vee popcnt(I_{E_\beta}) \neq N_{e,\beta}$. However, there are rare instances where this isn't true.

EXEMPLE avec 8bit?

Therefore, if $I_E - I_D = I_T$, additional checks are required to establish that $TD = E$.


Implementing this in Fortran may not looks straightforward considering in this language, integers are always signed, thus the leftmost bit has a special status. However, it is actually of no relevance except when it comes to sorting, and merely changing the sorting order won't cause any malfunction.
If "signed" sorting is however desired, it can easily be emulated. Be $X$ and $Y$ two 64-bit integers, $u_comp$ the unsigned comparison operator (the one used by Fortran) and $s_comp$ the signed comparison operator.

\begin{equation}
s\_comp(X,Y) = u\_comp(IEOR(X,ISHFT(1,63)), IEOR(Y,ISHFT(1,63))
\end{equation}


$IEOR(X,ISHFT(1,63)$ returns $X$ with bit at position 63 flipped. Bit are indexed from 0 so bit at position 63 is the leftmost one for 64-bit integers.

The algorithm for "excitation driven" connection finding is detailed in algorithm XX.


\begin{comment}




\begin{algorithm}
	\caption{base functions}
		
	\SetKwFunction{FMain}{AddBigint}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn(\tcc*[h]{co}){\FMain{some args}}{
		$overflow \gets 0$ \;
		\For{$i=1,N_{int}$}{
			$may \gets IOR(I[i], J[i])$ \;
			$will \gets IAND(I[i], J[i])$ \;
			$R[i] = I[i] + J[i] + overflow$ \;
			$overflow = ISHFT(IOR(will, IAND(may, not(R[i]))), -63)$ \;
		}
	}
\end{algorithm}


\begin{algorithm}
	\caption{base functions}
		
	\SetKwFunction{FMain}{AddBigint}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn(\tcc*[h]{co}){\FMain{some args}}{
		$i \gets 1$ \;
		$j \gets 1$ \;
		\While{$i \leq N_i \& j \leq N_j$}{
			\For{$\sigma = \{\alpha, \beta\}$}{
			$overflow \gets 0$ \;
			\For{$k=1,N_{int}$}{
				$m \gets I_i[k,\sigma] + E[k, \sigma] + overflow$ \;
				\uIf{$m > J_j[k, \sigma]$}{
					$j \gets j+1$ \;
					cycle i,j loop \;
				}\ElseIf{$m < J_j[k, \sigma]$}{
					$i \gets i+1$ \;
					cycle i,j loop \;
				}
				$may \gets IOR(I_i[k,\sigma], E[k, \sigma])$ \;
				$will \gets IAND(I_i[k,\sigma], E[k, \sigma])$ \;
				$overflow \gets ISHFT(IOR(will, IAND(may, not(m))), -63)$ \;
			}
			}
			\If{$EXC(I_i, J_j) \leq 2$}{
				$assert(J=EI)$ \;			
			}
		}
	}
\end{algorithm}





\begin{algorithm}
	\caption{base functions}
	\label{EXCITATION_DRIVEN}
	\SetKwFunction{FMain}{EXCITATION\_DRIVEN}
	\SetKwProg{Fn}{Function}{:}{}
	
		\Fn(\tcc*[h]{A VERIFIER}){\FMain{some args}}{
		$i \gets 1$ \;
		$j \gets 1$ \;
		

		\While{$i \leq N_i \& j \leq N_j$}{
			$aim \gets APPLY(I_i, E, ok)$ \;
			\If{$not\ ok$}{
				$i \gets i+1$ \;
				cycle \;
			}
			\While{$j \leq N_j$}{
				\tcc{find the index of $aim$ in $J$ in the range $[j, N_j]$. If not found, return the lowest $j$ so that $detCmp(aim, J_j) = 1$, or $N_{j}+1$ if $aim > J_{N_j}$.}
				$j \gets find(aim, J, j, N_j, ok)$ \;
				\If{$ok$}{
					found \;
				}
				%				$cmp \gets DetCmp(J_j, aim)$ \;
%				\uIf{$cmp = 1$}{
%					break \;
%				}\ElseIf{$cmp = 0$}{
%					found \;
%					break \;
%				}
%				$j \gets j+1$ \;
			}
		}

	}
	
			
	\SetKwFunction{FDetCmp}{DetCmp}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn(\tcc*[h]{co}){\FDetCmp{$I$, $J$}}{
		\For{$\sigma = \{\alpha, \beta\}$}{
		\For{$k=1,N_{int}$}{
			\uIf{$I_\sigma[k] > J_\sigma[k]$}{
				\KwRet{1} \;
			}\uElseIf{$I_\sigma[k] < J_\sigma[k]$}{
				\KwRet{-1} \;
			}
		}
		}
		\KwRet 0 \;
	}
\end{algorithm}
\end{comment}



\begin{algorithm}
	\caption{EXCITATION\_DRIVEN}
	\label{EXCITATION_DRIVEN}
	\SetKwFunction{FMain}{EXCITATION\_DRIVEN}
	\SetKwProg{Fn}{Function}{:}{}
	
		\Fn(\tcc*[h]{CHECK}){\FMain{$I$, $J$}}{
		$i \gets 1$ \;
		$j \gets 1$ \;
		

		\While{$i \leq N_I \& j \leq N_J$}{
			$aim \gets APPLY(I_i, E, ok)$ \;
			$j \gets find\_first\_geq(aim, J, j, N_j, match)$ \;				
			
			\If{$not(match) \& j \leq N_j$}{
				$aim \gets REVERSE\_APPLY(J_j, E, ok)$ \;
				$i \gets find\_first\_geq(aim, I, i, N_i, match)$ \;
				
			}
			\If{$match$}{
				\If{$ok$}{
					assert $J_j = \hat EI_i$ \;	
				}
				$i \gets i+1$ \;
			}
		}
	}

	
	
			
	\SetKwFunction{FDetCmp}{DetCmp}
	\SetKwProg{Fn}{Function}{:}{}
	
	\Fn(\tcc*[h]{REPLACE WITH find\_first\_geq}){\FDetCmp{$I$, $J$}}{
		\For{$\sigma = \{\alpha, \beta\}$}{
		\For{$k=1,N_{int}$}{
			\uIf{$I_\sigma[k] > J_\sigma[k]$}{
				\KwRet{1} \;
			}\uElseIf{$I_\sigma[k] < J_\sigma[k]$}{
				\KwRet{-1} \;
			}
		}
		}
		\KwRet 0 \;
	}
\end{algorithm}



\begin{equation}
(ij \rightarrow kl) = \big [(ij|kl) - (ij|lk) \big ] \times phase(S,ijkl)
\end{equation}


\begin{equation}
(i\bar j \rightarrow k\bar l) = (i\bar j|k\bar l) \times phase(S,i\bar jk\bar l)
\end{equation}




\begin{equation}
phase(S,ijkl) = P^S_i \oplus P^S_j \oplus P^S_{k+1} \oplus P^S_{l+1} \oplus (min(k,l)>max(i,j))
\end{equation}


\begin{equation}
phase(S,i\bar jk\bar l) = P^S_i \oplus P^S_{\bar j} \oplus P^S_{k+1} \oplus P^S_{\bar l+1}
\end{equation}



\begin{algorithm}
	\KwData{$I[]$ the children of $\kI$}
	
	\ForAll{$\ket {G_p}$ singly ionized generator}{
		\tcc{indexed by 1 hole and 2 particles}
		$c_\alpha[h,p1,p2]$ \;
		\tcc{$\kalpha = a_h a^\dagger_{p1} a^\dagger_{p2} \ket {G_p}$}
		\ForAll{$I,I[r],I[s]$}{
			$\alpha \gets I \oplus I[r] \oplus I[s]$ \;
			\tcc{check $||\alpha||$ ?}
			$x \gets G_p \oplus \alpha$ \;
			\If{$||x|| = 3$}{
				$(h,p1,p2) \gets \texttt{BITSTRING\_TO\_LIST}(x)$ \;
				increment $c_\alpha[h,p1,p2]$ \;		
			}
		}
	}
\end{algorithm}




\begin{algorithm}
	\label{BUILD_MICROLIST}
	\caption{BUILD\_MICROLIST}
		\KwData{ ------}
		\KwResult{ ------}
        $N \gets 0$ \;
        $N^* \gets 0$ \;   
        $N^{*,*} \gets 0$ \;    
        \ForAll{$I \in \{S - past\} ; f_{G_{pq}}^I \leq 4$}{
          $(P,H) \gets particles\_and\_holes(G_{pq}, I)$ \;
          $p = list\_from\_bitstring(P)$ \;
          
          %$h = LIST_FROM_BITSTRING(H)$
          \uIf{$f_{G_{pq}}^I = 4$ \& $B_{p_1,p_2}$}{
            $i \gets N^{p_1, p_2}+1$ \;
            $N^{p_1, p_2} \gets i$ \;
            $D^{p_1, p_2}_{i} \gets I$ \;
          }
          \uElseIf{$f_{G_{pq}}^I = 3$ \& $B_{p_1}$}{
            $i \gets N^{p_1}+1$ \;
            $N^{p_1} \gets i$ \;
            $D^{p_1}_{i} \gets I$ \;
          }
          \Else{
            $i \gets N+1$ \;
            $N \gets i$ \;
            $D_{i} \gets I$ \;
          }
        }
\end{algorithm}


\begin{comment}
\begin{algorithm}
	\caption{Build $\mathcal{C}_{rs}$ from $\tilde{\mathcal{C}}_{rs}$}
	\label{alg:compute_connected}
	\tcc{This takes place after $\tilde{\mathcal{C}}_{rs}$ and $B_{rs}$ for a given batch have been fully computed}
		\KwData{$\tilde{\mathcal{C}}_{rs}$ the intermediate sets, $B_{rs}$ the tag matrix}
		%\KwResult{$Z^\star(\Gpqrs, \mathcal{C}_{rs})$ is called for all $\Gpqrs$ of $G_{pq}$ batch that are unique $\kalpha$}
		\KwResult{$\mathcal{C}_{rs}$ is computed for all $\Gpqrs$ of $G_{pq}$ batch that are unique $\kalpha$}
        $i_1 = N$ \;   
        $L_{1..i_1} \gets D_{1..{i_1}}$ \;
		\tcc {$B_{r0} = FALSE$ if column entirely tagged}		
		\ForAll{$r ; B_{r0}$}{
		  $i_2 = i_1 + N^r$ \;
		  $L_{i_1+1..i_2} \gets D^r_{1..N^r}$ \;
		  \For{$i=1,N_r$}{
		    $T_{D^r_i} \gets FALSE$
		  }
		  \alert{est-ce que $B_{rr}$ est tage?} \;
		  \ForAll{$s \neq r ; B_{rs}$}{
		    $i_3 = i_2$ \;
		    \For{$i=1,N_s$}{
		      \If{$T_{D^s_i}$}{
		        $i_3 \gets i_3+1$ \;
		        $L_{i_3} \gets D^s_i$ \;
		      }
		    }
		    
		    $i_4 = i_3 + N^{rs}$ \;
		    $L_{i_3+1 .. i_4} \gets D^{rs}_{1..N^{rs}}$ \;
		    \tcc{$L$ is the list of all $I \in \Psi ; EXC(I, a^\dagger_r a^\dagger_s G_{pq} ) \leq 2$}
		  }
		 \For{$i=1,N_s$}{
		    $T_{D^r_i} \gets TRUE$
		  }
		}
\end{algorithm}
\end{comment}